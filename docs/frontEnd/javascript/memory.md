---
id: memory
sidebar_position: 8
title: 内存
---

## 内存
### 栈内存
存放**基本数据类型**。

原始数据类型的内存大小是固定的，由系统自动分配内存空间。

存放变量名和值。定义变量的过程是入栈的过程。

池：存放常量 number string boolean

### 堆内存
存放**引用类型**。

使用引用类型变量时候是通过引用使用的，引用可以理解为是存放在栈内存中的**堆内存地址**。

栈中存放的变量对应的值是堆内存的地址(16进制)。

定义对象或者方法时，首先在堆中开辟一块空间存储对象或方法体字符串，然后将堆中的内存地址赋值给栈中的变量值。

### 函数定义和函数表达式

```
function fun(){
    console.log(1)
}
var fun = function(){
    console.log(2)
}
console.log(fun)
```
1. 变量声明提升 var fun 存放在 **栈** 中
2. fun(){1} 函数存放在 **堆** 的函数定于区内
3. fun = function(){2} 匿名函数存放在 **堆** 的函数定于区内，并立即将地址赋值给变量 fun 

找函数时，优先读取**栈**里的变量，没有定义再去**堆**中找。

但是下边两个输出结果不一样，
```
function fun(){
    console.log(1)
}
var fun
console.log(fun)
```
```
function fun(){
    console.log(1)
}
var fun = undefined
console.log(fun)
```
`var fun` 和 `var fun = undefined` 这两个不是一个概念，
- `var fun` 表示 fun 没有指向任何地址。
- `var fun = undefined` 表示 fun 内有地址，指向的是 `undefined` 。
- 在找函数的时候 `var fun` 会检测到**栈**中没有值，去**堆**中找 fun()
- 而 `var fun = undefined` 则会检测为**栈**中有值，输出 undefined 不再去**堆**中查找。

## 垃圾回收
JavaScript 引擎找出那些不再继续使用的变量，然后释放其所占用的内存，垃圾回收器会按照固定的时间间隔周期性地执行这一操作。
### 优点
- 可以大幅度简化内存管理代码，降低开发负担。
- 减少因长时间运转带来的内存泄漏问题。
### 缺点
- JavaScript 没有暴露内存相关API，无法完全掌控内存。
- 无法强制进行垃圾回收，无法干预内存管理。

### 垃圾回收策略
- 引用计数(IE8及以前)
  - 跟踪记录每个值被引用的次数，每次引用次数加一，释放时次数减一，当次数为0说明这个值不再用到，可以被回收。
  - 循环引用(相互引用)会导致这种垃圾回收机制无法回收。
- **标记清楚**(现在主流浏览器)
  - 当变量进入环境(运行时环境)时，这个变量会被标记为“进入环境”，当变量离开环境时则被标记为“离开环境”。垃圾回收器销毁并回收那些被标记为“离开环境”的值所占用的内存空间。
  - **执行环境**定义了变量和函数有权访问的其他数据，当环境中的所有代码执行完毕后该环境销毁，保存在环境里的变量和方法也随之销毁；每个执行环境都会对应一个变量对象包含这个环境中定义的变量和函数。代码中无法访问这个变量，但是js解析器会在后台使用这个变量对象。执行环境分为**全局执行环境**和**局部执行环境**。
  - 全局执行环境：
    1. 是最外层的执行环境；
    2. 根据宿主环境不同表示执行环境的变量对象也不一样。浏览器中全局执行环境是 windows 对象； Node中，全局执行环境是 Global 对象；
    3. 全局的变量和函数都作为 window 对象的属性和方法创建的。
    4. 全局环境直到程序退出才销毁，如关闭网页或浏览器。
  - 局部执行环境
    1. 每个函数都有自己的的执行环境，成为局部执行环境。
    2. 当函数被调用时产生一个局部执行环境，推到执行栈中；当执行完毕后，执行栈将其环境推出；将执行权交给之前的执行环境。
    3. 进入全局代码时默认进入全局执行环境，当调用某个方法时执行权进入这个函数中，创建一个局部执行环境推如执行栈中。
- **分代回收**(V8回收策略)
  - V8 将内存分为**新生代**和**老生代**；对两个生代采用不同的垃圾回收算法。
  - 新生代
    1. 新生代将内存分成 from 和 to 两个空间，初始值变量存放在 from 中，垃圾回收时候检测存活的变量**复制**到 to 中，然后from和to反转，垃圾回收将 to 中的所有内存回收。
    2. 在新生代垃圾回收过程中，当一个对象被多次复制后仍然存活，会被认为是生命周期较长的对象，随后被移动到老生代中，采用新的算法管理。
    3. 在 form 和 to 反转的过程中，如果 to 空间使用量超过 25% 那么 from 中的对象直接晋升到老生代。
  - 老生代
    1. 内存是连续的；分为标记合并和标记清除两种策略
    2. **标记清除**(Mark Sweep) —— 对回收对象进行标记，在垃圾回收时直接释放相应的内存地址。会导致内存地址不连续的情况。
    3. **标记合并**(Mark Compact) —— 将存活对象移动到一边，将需要回收的对象移动到另一边，然后对回收区域整体回收。

